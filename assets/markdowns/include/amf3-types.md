* Undefined
  * AMF3 型マーカの数値: 0
  * メッセージ長: 0 byte
  * 値: なし. マーカのみを入力する. AVM 以外のエンドポイントでは未定義の概念がなく, 当該データ型を AMF での Null として扱う場合があることに注意が必要である.
* Null
  * AMF3 型マーカの数値: 1
  * メッセージ長: 0 byte
  * 値: なし. マーカのみを入力する.
* False
  * AMF3 型マーカの数値: 2
  * メッセージ長: 0 byte
  * 値: なし. マーカのみを入力する. 当該データ型は AMF3 における真偽値の**偽**として扱う.
* True
  * AMF3 型マーカの数値: 3
  * メッセージ長: 0 byte
  * 値: なし. マーカのみを入力する. 当該データ型は AMF3 における真偽値の**真**として扱う.
* Integer
  * AMF3 型マーカの数値: 4
  * メッセージ長: 29 **bits**
  * 値: [29 bits](#integer-型%2C-長さ%2C-要素の総数) の整数. 28 bits の範囲を上回ったり下回ったりする場合は, AMF3 の Double 型を用いてシリアライズされる.
* Double
  * AMF3 型マーカの数値: 5
  * メッセージ長: 8 bytes
  * 値: 8 bytes の浮動小数点数.<br>エンコード/デコードの方法は AMF0 の Number 型と同じである.
* String
  * AMF3 型マーカの数値: 6
  * メッセージ長: 可変
  * 値: UTF-8 の文字列.<br>最初の [29 bits](#integer-型%2C-長さ%2C-要素の総数) には参照値または文字列の長さを入力する.
* XMLDocument
  * AMF3 型マーカの数値: 7
  * メッセージ長: 可変
  * 値: UTF-8 でエンコードされた XML の文字列表現. ActionScript 3 では新しい XML 型があるが, 古い XMLDocument 型が flash.xml.XMLDocument として言語に残されている.
* Date
  * AMF3 型マーカの数値: 8
  * メッセージ長: 29 bits + 8 bytes
  * 値: 8 bytes の浮動小数点数のバイナリ表記. UTC 基準のタイムスタンプを浮動小数点数として入力する. 最初の [29 bits](#integer-型%2C-長さ%2C-要素の総数) は AMF3 の Integer の値や String の長さと同じフォーマットであるが, 値(最下位ビットのフラグが 1)として入力する場合は残りの 28 bits には何も入力しない.
* Array
  * AMF3 型マーカの数値: 9
  * メッセージ長: 可変
  * 値: 当該データ型には以下の 3 つのフォーマットがある.
    * 参照であることを示す [29 bits](#integer-型%2C-長さ%2C-要素の総数) のフォーマット
    * 要素の総数([29 bits](#integer-型%2C-長さ%2C-要素の総数))と, 空要素(1 -&gt; 値なし)のみの場合も含む ECMA (連想)配列 (名前と値(どちらも AMF3 でエンコードされたもの)のペア)
    * 順序インデックスによる厳密な配列

ECMA 配列フォーマットの場合は空要素を最後の要素として 1 つ置かなければならない. また, 厳密な配列フォーマットは ECMA 配列フォーマットの末尾の空要素に続いて入力し, 要素の総数を ECMA 配列フォーマットの要素の総数に加える.

* Object
  * AMF3 型マーカの数値: 10
  * メッセージ長: 可変
  * 値: 当該データ型には以下の 6 つのフォーマットがある.
    * 当該データ型の参照であることを示す [29 bits](#integer-型%2C-長さ%2C-要素の総数) のフォーマット
    * トレイトのメンバのバイナリであることを示す([29 bits](#トレイトのバイナリ%2C-メンバの総数%2C-トレイトの参照)) + トレイトの特質とメンバのバイナリのペア
    * トレイトの参照であることを示す [29 bits](#トレイトのバイナリ%2C-メンバの総数%2C-トレイトの参照) のフォーマット
    * トレイトのメンバの総数([29 bits](#トレイトのバイナリ%2C-メンバの総数%2C-トレイトの参照)) + トレイトの特質と(AMF3 でエンコードされた)メンバ名のペア
    * 1 つ以上のトレイトのメンバの(AMF3 でエンコードされた)値
    * 1 つ以上の**動的な**メンバ (名前と値(どちらも AMF3 でエンコードされたもの)のペア)

ここで, トレイトの特質とは以下の 4 つの内 1 つを指す AMF3 の文字列である.

* anonymous: 匿名のオブジェクト. 空文字("")を入力する.
* typed: 名前付きのオブジェクト.
* dynamic: 名前付き かつ 動的なメンバを持つオブジェクト.
* externalizable: **外部のプログラムが変換可能な**名前を持つオブジェクト.

**Object 型としての**参照値もしくはトレイトのフォーマットの直後にメンバの実際の値が続き, 動的なメンバがあれば更にその直後にそれが続く形になる.

* XML
  * AMF3 型マーカの数値: 11
  * メッセージ長: 可変
  * 値: UTF-8 でエンコードされた XML の文字列表現.
* ByteArray
  * AMF3 型マーカの数値: 12
  * メッセージ長: 可変
  * 値: 1 byte 符号なし整数の配列.
* Vector&lt;Int&gt;
  * AMF3 型マーカの数値: 13
  * メッセージ長: 可変
  * 値: 4 bytes **符号付き** 整数の配列. [29 bits](#integer-型%2C-長さ%2C-要素の総数) の直後の 1 byte は 1 ならその配列が固定長であることを, 0 なら可変長であることを意味する.
* Vector&lt;UInt&gt;
  * AMF3 型マーカの数値: 14
  * メッセージ長: 可変
  * 値: 4 bytes **符号なし** 整数の配列. 以下同上.
* Vector&lt;Double&gt;
  * AMF3 型マーカの数値: 15
  * メッセージ長: 可変
  * 値: 8 byte **浮動小数点数**(のバイナリ表記)の配列. 以下同上.
* Vector&lt;Object&gt;
  * AMF3 型マーカの数値: 16
  * メッセージ長: 可変
  * 値: **AMF3 のデータ型**の配列. 固定長かどうかのフラグの直後に AMF3 のデータ型の名前(AMF3 でエンコードされた文字列)を入力し, 以降にその名前で表現される AMF3 データの実体を入力する. 以下同上.
* Dictionary
  * AMF3 型マーカの数値: 17
  * メッセージ長: 可変
  * 値: 名前と値(どちらも AMF3 でエンコードされたもの)のペア. Object 型との違いは**キーを任意の AMF3 データ型にできる**ことである. [29 bits](#integer-型%2C-長さ%2C-要素の総数) の直後の 1 byte は 1 ならキーが弱参照であることを, 0 ならそうでないことを意味する.

なお, AMF3 における 29 bits のフィールドの内訳は以下の通りである.

##### Integer 型, 長さ, 要素の総数

* 最下位ビットが 0 の場合

そのデータは参照であり, 残りの 28 bits は参照テーブルのインデックス(整数)を入力する.

* 〃 1 の場合

そのデータは実際の値であり, 残りの 28 bits には続く文字列の長さなどの整数を入力する.

##### トレイトのバイナリ, メンバの総数, トレイトの参照

* バイナリの場合

最下位 **3 bits** に **0b111** を入力する. メンバの総数として常に 0 を入力することになるため, 残りの 26 bits には意味がない.

* **トレイトの**参照の場合

最下位 **2 bits** に **0b01** を入力する. 2 bit 目は **Object 型のトレイトが**参照で送られていることを意味する値(0)である. 残りの 27 bits にはトレイトの参照のインデックスを入力する.

* メンバの総数の場合

最下位 **4 bits** に **0bX011** を入力する. X は 1 なら動的なトレイトである(動的なメンバを持つ)ことを, 0 ならそうでないことを意味する. 残りの 25 bits にはトレイト名の直後に入力する**静的なメンバの**総数を入力する.
